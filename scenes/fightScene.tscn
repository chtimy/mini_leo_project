[gd_scene load_steps=3 format=2]

[ext_resource path="res://images/mini_leo/cote_droit.png" type="Texture" id=1]

[sub_resource type="GDScript" id=1]

script/source = "extends Node2D

#struct Character
#{
	#string name
	#string category
	#string path to texture
	#int life
	#float %attack
	#float %defence
	#float ...
	#int attacks []
	#int group
	#int nbDeplacementBase
	#int orientation
	#vector2 position
	#...
	#graphics
#}

# Dictionnary of :
#struct Action
#{
#	string name
#	string pathToTexture[]
#	int actionId
#}

const RIGHT = 0
const LEFT = 1

var m_actions = { }

var m_nbVilains = 4
var m_characters = []
var m_objects = []

var m_menusAttack = []
#order of turns
var m_turns = []
var m_currentMenuAttack
var m_pendingTurn = false

var m_map

var tileSize = Vector2(100.0, 100.0)

func _ready():
	if readActionsFile():
		#base de test : ( a supprimer )
		var characters = []
		var character = {
			name = \"leo\",
			life = 5,
			actions = [\"cross\", \"posterize\"],
			nb_deplacementBase = 3,
			category = \"Player\",
			texturePath = \"res://images/map/fightScene/character.png\"
		}
		var ennemi = {
			name = \"ennemi\",
			life = 2,
			actions = [\"cross\"],
			category = \"Enemi\",
			texturePath = \"res://images/map/fightScene/ennemi.png\"
		}
		characters.append(character)
		characters.append(ennemi)
		var objects = []
			
		init(\"res://data/fightScene/mapFight01.txt\", characters, objects)
		#fin base de test
		set_process(true)

# initialisation de la scène de combat 
# matrix : map de la scène de combat
# characters : personnages et ennemis dans la zone de combat
# objects : objets dans la zone de combat
func init(var mapName, var characters, var objects):
	if readMapFile(mapName):
		m_characters = characters
		var i = 0
		var j = 0
		#init position and orientation characters
		for character in m_characters:
			if character.category == \"Player\":
				character.position = m_map.initialPositions[0][i]
				j += 1
			elif character.category == \"Enemi\":
				character.position = m_map.initialPositions[1][i]
				i += 1
		m_objects = objects
	
		#construction graphique de la zone de combat
		buildGraphics()
		#init turns
		m_turns.push_back(0)
		m_turns.push_back(1)
	
#Destruction de la zone de combat
func destroy():
	m_map = []
	m_characters = []
	m_objects = []
	# Destruction graphique de la zone de combat
	destroyGraphics()

#Destruction graphique de la zone de combat
func destroyGraphics():
	pass

#Construction de la zone de combat
func buildGraphics():
	#map generation
	m_map.graphicsMap = Node2D.new()
	m_map.graphicsMap.set_script(load(\"res://scripts/fightMap.gd\"))
	m_map.graphicsMap.init(m_map, tileSize, \"res://images/map/fightScene/overlay.png\", get_viewport())
	add_child(m_map.graphicsMap)
		
	#characters generation
	for character in m_characters:
		#init menu
		character.menu = load(\"res://scenes/menuActionsFight.tscn\").instance()
		add_child(character.menu)
		character.menu.init(m_actions, character.actions)
		character.menu.set_visible(false)
		#init graphics character (position, orientation)
		character.graphics = Sprite.new()
		character.graphics.set_texture(load(character.texturePath))
		character.graphics.set_scale(tileSize/character.graphics.get_texture().get_size())
		character.graphics.set_position(character.position * tileSize)
		character.graphics.set_centered(false)
		add_child(character.graphics)
	m_currentMenuAttack = m_characters[0].menu
		#creation character node
		#character.graphicsCharacter = ???
	#objects generation
	#for object in m_objects:

func _process(delta):
	#Players turn
	playerTurn()
	#Enemis turn (IA)
	pass

#gestion du tour du joueur
func playerTurn():
	if m_pendingTurn == false:
		m_currentMenuAttack = m_characters[m_turns.front()].menu
		m_currentMenuAttack.set_visible(true)
		m_pendingTurn = true
	#si menu retourne action
	var action =  m_currentMenuAttack.getAction()
	if action != null :
		print(action)
		#exec action
		
		#hide currentMenu 
		m_currentMenuAttack.reinit()
		m_currentMenuAttack.set_visible(false)
		#if pas mort alors on met le tour derriere
		m_turns.push_back(m_turns.pop_front())
		m_pendingTurn = false

#import actions file
func readActionsFile():
	#a optimiser
	var line
	var actionsFightFile = File.new()
	#a mettre en binaire
	if actionsFightFile.open(\"res://data/fightScene/actions.txt\", File.READ) == 0:
		var nb = nextLine(actionsFightFile)
		for i in range(nb):
			var action = {
				name = nextLine(actionsFightFile),
				id = nextLine(actionsFightFile),
				pathToTexture = [nextLine(actionsFightFile), nextLine(actionsFightFile)],
				ptsAttack = nextLine(actionsFightFile),
				ptsDefence = nextLine(actionsFightFile),
				portee = nextLine(actionsFightFile),
				direction = nextLine(actionsFightFile),
				effects = []
			}
			var nbEffects = nextLine(actionsFightFile)
			for i in range(nbEffects):
				action.effects.append(nextLine(actionsFightFile))
			if m_actions.has(action.name) == true:
				print(\"Attention, clef double pour l'entrée dans le dictionnaire d'une action\")
			else :
				m_actions[action.name] = action
		actionsFightFile.close()
		return true
	return false

#import actions file
func readMapFile(var path):
	#a optimiser
	var line
	var mapFile = File.new()
	m_map = {
	}
	#a mettre en binaire
	if mapFile.open(path, File.READ) == 0:
		#read textures
		var nb = nextLine(mapFile)
		m_map.textures = []
		for i in range(nb):
			m_map.textures.append(nextLine(mapFile))
		#read initial positions for characters (0) enemis (1) and objects (2)
		m_map.initialPositions = []
		for k in range(3):
			nb = nextLine(mapFile)
			m_map.initialPositions.append([])
			for i in range(nb):
				var a = nextLine(mapFile).split_floats(\" \")
				m_map.initialPositions[k].append(Vector2(a[0], a[1]))
		#read matrix
		m_map.matrix = []
		var a = nextLine(mapFile).split_floats(\" \")
		var sizeMatrix = Vector2(a[0], a[1])
		for i in range(sizeMatrix.x):
			m_map.matrix.append([])
			var b = nextLine(mapFile).split_floats(\" \")
			for j in range(sizeMatrix.y):
				m_map.matrix[i].append(b[j])
		mapFile.close()
		return true
	return false

func nextLine(var actionsFightFile):
	if actionsFightFile.eof_reached():
		print(\"Attention fin de fichier atteint, la ligne suivante n'existe pas\")
	var line = actionsFightFile.get_line()
	while lineOK(line) == 0 :
		line = actionsFightFile.get_line()
	return line

func lineOK(var line):
	if line.empty():
		return 0
	for c in line:
		#prob ici il faut mettre que des espaces avant!
		if c.match(\"*#\"):
			return 0
	return 1
	
	"

[node name="fightScene" type="Node2D"]

script = SubResource( 1 )
_sections_unfolded = [ "Z Index" ]

[node name="background" type="Sprite" parent="." index="0"]

visible = false
centered = false
region_rect = Rect2( 0, 0, 2000, 1000 )
_sections_unfolded = [ "Animation", "Offset", "Region", "Transform", "Z Index" ]

[node name="leo" type="Sprite" parent="." index="1"]

visible = false
texture = ExtResource( 1 )


